#!/usr/bin/env node
'use strict'

const updateNotifier = require('update-notifier')
const pkg = require('../package.json')
const chalk = require('chalk')
const spinner = require('ora')()
const program = require('commander')
const logUpdate = require('log-update')
const prettyBytes = require('pretty-bytes')
const stringWidth = require('string-width')
const createTable = require('text-table')
const jsize = require('../index')
const originalLog = console.log

// Check for cli updates.
updateNotifier({pkg: pkg}).notify()

// Parse cli options.
program
  .usage('[options] <name ...>')
  .option('-v, --verbose', 'display initial, minified and gzipped size')
  .option('-t, --target [target]', 'change webpack target (default is web)', 'web')
  .parse(process.argv)

// Store results for rendering later.
const bundles = []
const headings = [
  'Package',
  '',
  'Initial',
  'Minified',
  'Gzipped'
].map(heading => chalk.dim(heading))

if (program.args.length > 0) {
  // Start cli render loop.
  const interval = setInterval(render, 100)

  // Build and analyze packages sequentially.
  program
    .args
    .reduce((p, pkgs) => {
      const bundle = {
        name: pkgs.replace(/\+/g, chalk.dim(' + ')),
        stats: null
      }
      bundles.push(bundle)

      return p.then(() => {
        return jsize(pkgs.split('+'), { target: program.target })
          .then(result => { bundle.stats = result })
          .catch(err => { bundle.error = err.message })
      })
    }, Promise.resolve())
    .then(() => {
      clearInterval(interval)
      render()

      const err = bundles
        .map(bundle => bundle.error)
        .filter(Boolean)
        .join('\n')

      if (err) {
        console.error(chalk.red(err))
        process.exit(1)
      }
    })
    .catch(err => {
      console.error(err)
      process.exit(1)
    })
} else {
  program.help()
}

/**
 * Parses program args to list of bundles, each bundle is list of packages.
 * Example: "a + c b" -> [ ['a', 'b'], ['c'] ]
 *
 * @param {array} args
 * @returns {array}
 */
function parse (args) {
  // Tokenize args to standard form: ['a+c', '+', 'b'] -> ['a', '+', 'c', '+', 'b']
  const tokens = args
    .join(' ')
    .replace(/\+/g, ' + ')
    .split(' ')
    .filter(s => s !== '')

  const next = () => tokens.shift()
  const pack = () => {
    lookahead && x[x.length - 1].push(lookahead)
    lookahead = next()
  }

  let x = []
  let lookahead = next()

  do {
    x.push([])
    pack()
    while (lookahead === '+') {
      lookahead = next()
      pack()
    }
  } while (lookahead || tokens.length > 0)

  return x
}

/**
 * Renders a table with the current results to the terminal.
 */
function render () {
  const loading = spinner.frame()
  const table = bundles.map(bundle => {
    const stats = bundle.stats
    const row = [
      bundle.name,
      chalk.dim('=')
    ]

    if (stats) {
      if (program.verbose) {
        row.push(
          prettyBytes(stats.initial),
          prettyBytes(stats.minified),
          colorBytes(stats.gzipped)
        )
      } else {
        row.push(colorBytes(stats.gzipped) + chalk.dim(' (gzipped)'))
      }
    } else {
      const fill = bundle.error ? chalk.red('X') : loading
      row.push(fill)

      if (program.verbose) {
        row.push(fill, fill)
      }
    }

    return row
  })

  if (program.verbose) {
    table.unshift(headings, [''])
  }

  // Enable logs for long enough to print to the screen.
  const curLog = console.log
  console.log = originalLog
  logUpdate(
    '\n' +
    createTable(table, { stringLength: stringWidth })
      .split('\n')
      .map(s => '  ' + s)
      .join('\n') +
    '\n'
  )
  console.log = curLog
}

/**
 * Converts bytes into human readable, color coated format.
 *
 * @param {number} n - the number of bytes.
 * @return {string}
 */
function colorBytes (n) {
  const str = prettyBytes(n)
  if (n < 1000) {
    return chalk.underline.green(str)
  } else if (n < 5000) {
    return chalk.green(str)
  } else if (n < 50000) {
    return chalk.yellow(str)
  } else {
    return chalk.red(str)
  }
}
