#!/usr/bin/env node
'use strict'

// Check for cli updates.
const updateNotifier = require('update-notifier')
const pkg = require('../package.json')
updateNotifier({ pkg: pkg }).notify()

const chalk = require('chalk')
const padEnd = require('pad-end')
const program = require('commander')
const prettyBytes = require('pretty-bytes')
const spinner = require('ora')('Starting...').start()
const jsize = require('../index')

/**
 * Normalizes cli arguments list.
 * Replaces `jsize react + react-dom`
 * With `jsize react+react-dom`
 */
process.argv.forEach((arg, i, args) => {
  if (arg === '+') {
    const prev = args[i - 1]
    const next = args[i + 1]
    args.splice(i - 1, 3, prev + '+' + next)
  }
})

// Parse cli options.
program
  .usage('[options] <name ...>')
  .option('-v, --verbose', 'Display initial, minified and gzipped size.')
  .parse(process.argv)

// Calucate the padding based on the longest package name.
const padding = 4 + program.args.reduce(maxLength, 0)

if (program.args.length > 0) {
  // Build and analyze packages sequentially.
  program
    .args
    .reduce((p, pkgs) => p.then(() => {
      spinner.text = colorName(pkgs)
      spinner.start()
      return jsize(pkgs.split('+'))
        .then(print)
        .catch(err => spinner.fail(err.message))
    }), Promise.resolve())
    .catch(err => console.error(err))
} else {
  program.help()
}

/**
 * Reducer to calculate the max length.
 *
 * @param {number} max - the current maximum.
 * @param {string|array} it - the item being tested.
 * @return {number}
 */
function maxLength (max, it) {
  return Math.max(max, colorName(it).length)
}

/**
 * Logs stats from jsize results.
 *
 * @param {object} result - the sizes from jsize.
 */
function print (result) {
  let info = ''
  if (program.verbose) {
    info += padEnd(prettyBytes(result.initial) + ' (initial)', 20, ' ')
    info += padEnd(prettyBytes(result.minified) + ' (minified)', 20, ' ')
  }
  info += colorBytes(result.gzipped) + ' (gzipped)'
  spinner.succeed(padEnd(spinner.text, padding, ' ') + info)
}

/**
 * Converts bytes into human readable, color coated format.
 *
 * @param {number} n - the number of bytes.
 * @return {string}
 */
function colorBytes (n) {
  const str = prettyBytes(n)
  if (n < 1000) {
    return chalk.underline.green(str)
  } else if (n < 5000) {
    return chalk.green(str)
  } else if (n < 50000) {
    return chalk.yellow(str)
  } else {
    return chalk.red(str)
  }
}

/**
 * Adds colors to package name.
 *
 * @param {string} pkgs - the package names to color.
 * @return {string}
 */
function colorName (pkgs) {
  return pkgs.replace(/\+/g, chalk.dim(' + '))
}
